<!DOCTYPE html>
<html>
<head>
    <title>DocBench Performance Report - BSON vs OSON Benchmarks</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #333; border-bottom: 3px solid #0066cc; padding-bottom: 10px; }
        h2 { color: #0066cc; margin-top: 30px; }
        h3 { color: #666; margin-top: 20px; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: right; }
        th { background: #0066cc; color: white; }
        td:first-child { text-align: left; font-weight: 500; }
        tr:nth-child(even) { background: #f9f9f9; }
        tr:hover { background: #f0f7ff; }
        .winner-mongo { color: #cc6600; font-weight: bold; }
        .winner-oson { color: #006600; font-weight: bold; }
        .summary-box { background: #f0f7ff; border: 1px solid #0066cc; border-radius: 8px; padding: 20px; margin: 20px 0; }
        .highlight { background: #ffffcc; }
        .metric { font-size: 24px; font-weight: bold; color: #0066cc; }
        .section { margin: 30px 0; }
        .note { color: #666; font-style: italic; font-size: 0.9em; }
        .description { background: #f9f9f9; border-left: 4px solid #0066cc; padding: 15px; margin: 15px 0; }
        .comparison { display: flex; gap: 20px; }
        .comparison > div { flex: 1; }
        .test-category { background: #e8f4fc; border-radius: 4px; padding: 10px 15px; margin: 10px 0; }
        code { background: #f0f0f0; padding: 2px 6px; border-radius: 3px; font-family: 'Consolas', monospace; }
    </style>
</head>
<body>
<div class="container">
    <h1>DocBench Performance Report</h1>
    <p class="note">MongoDB BSON vs Oracle OSON - Comprehensive Benchmark Results</p>
    <p class="note">Generated: January 8, 2026 | Configuration: Single-member replica set with w:1, j:true</p>

<div class="summary-box">
    <h2>Executive Summary</h2>
    <div class="comparison">
        <div>
            <h3>Server-Side Updates</h3>
            <p class="metric">OSON 1.19x faster</p>
            <p>MongoDB wins: 3 | OSON wins: 22</p>
        </div>
        <div>
            <h3>Client-Side Field Access</h3>
            <p class="metric">OSON 71.24x faster</p>
            <p>MongoDB wins: 0 | OSON wins: 8</p>
        </div>
    </div>
</div>

<div class="section">
    <h2>Test Environment</h2>
    <div class="description">
        <p><strong>Durability Parity Configuration:</strong> Both databases are configured for equivalent durability guarantees.</p>
        <ul>
            <li><strong>MongoDB:</strong> Single-member replica set with <code>WriteConcern(w:1, j:true)</code> - waits for journal sync before acknowledging</li>
            <li><strong>Oracle:</strong> Standard configuration - always waits for redo log sync before acknowledging (mandatory)</li>
        </ul>
        <p>This ensures a fair comparison where both databases pay the same durability cost.</p>
    </div>
    <table>
        <tr><th>Component</th><th>Version/Configuration</th></tr>
        <tr><td>Oracle Database</td><td>26ai Free (23.26.0.0.0)</td></tr>
        <tr><td>MongoDB</td><td>8.0.16 (single-member replica set)</td></tr>
        <tr><td>Java</td><td>OpenJDK 23.0.2</td></tr>
        <tr><td>Platform</td><td>WSL2 Linux (Windows 11)</td></tr>
        <tr><td>Warmup Iterations</td><td>100</td></tr>
        <tr><td>Measurement Iterations</td><td>1,000 (100 for large arrays)</td></tr>
    </table>
</div>

<div class="section">
    <h2>Part 1: Client-Side Field Access (O(n) vs O(1))</h2>
    <div class="description">
        <p><strong>What this measures:</strong> The time to access a single field from an already-fetched document on the client side.</p>
        <ul>
            <li><strong>BSON (MongoDB):</strong> Uses <code>RawBsonDocument.get()</code> which performs sequential O(n) scanning through the binary document to find the requested field</li>
            <li><strong>OSON (Oracle):</strong> Uses <code>OracleJsonObject.get()</code> which performs O(1) hash-indexed lookup directly to the field offset</li>
        </ul>
        <p><strong>Why it matters:</strong> For documents with many fields, BSON's linear scanning becomes increasingly expensive while OSON maintains constant-time access regardless of field position.</p>
    </div>

    <h3>Field Position Tests</h3>
    <div class="test-category">
        Tests access fields at different positions (1st, 50th, 100th, etc.) to demonstrate O(n) vs O(1) scaling behavior.
    </div>
    <table>
        <tr><th>Test Case</th><th>BSON (ns)</th><th>OSON (ns)</th><th>Ratio</th><th>Winner</th></tr>
        <tr><td>Position 1/100 - First field in 100-field doc</td><td>250</td><td>99</td><td>2.53x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Position 50/100 - Middle field in 100-field doc</td><td>2,491</td><td>87</td><td>28.63x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Position 100/100 - Last field in 100-field doc</td><td>3,250</td><td>52</td><td>62.50x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Position 500/500 - Last field in 500-field doc</td><td>15,699</td><td>108</td><td>145.36x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Position 1000/1000 - Last field in 1000-field doc</td><td>31,195</td><td>59</td><td>528.73x</td><td class='winner-oson'>OSON</td></tr>
    </table>

    <h3>Nested Field Access Tests</h3>
    <div class="test-category">
        Tests access fields at varying depths of nesting (e.g., <code>doc.level1.level2.level3.field</code>).
    </div>
    <table>
        <tr><th>Test Case</th><th>BSON (ns)</th><th>OSON (ns)</th><th>Ratio</th><th>Winner</th></tr>
        <tr><td>Nested depth 1 - Single level nesting</td><td>598</td><td>110</td><td>5.44x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Nested depth 3 - Three levels deep</td><td>1,363</td><td>115</td><td>11.85x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Nested depth 5 - Five levels deep</td><td>2,144</td><td>170</td><td>12.61x</td><td class='winner-oson'>OSON</td></tr>
    </table>

    <div class="summary-box">
        <h3>Client-Side Summary</h3>
        <p><strong>Total:</strong> BSON 56,990 ns vs OSON 800 ns = <strong>71.24x faster for OSON</strong></p>
        <p><strong>Key Insight:</strong> BSON time increases linearly with field position (O(n) scaling), while OSON remains constant (~100ns) regardless of position (O(1)).</p>
    </div>
</div>

<div class="section">
    <h2>Part 2: Server-Side Update Performance</h2>
    <div class="description">
        <p><strong>What this measures:</strong> The time to update field(s) in a document stored in the database, including network round-trip and durability guarantees.</p>
        <ul>
            <li><strong>MongoDB:</strong> Uses <code>$set</code> operator with <code>WriteConcern(w:1, j:true)</code></li>
            <li><strong>Oracle:</strong> Uses <code>JSON_TRANSFORM</code> SQL function for partial OSON updates</li>
        </ul>
        <p><strong>Why it matters:</strong> Server-side updates are the most common operation in document databases. OSON's partial update capability allows modifying specific fields without rewriting the entire document.</p>
    </div>

    <h3>Protocol Overhead Baseline</h3>
    <div class="test-category">
        Measures the fixed cost of a database round-trip using non-JSON operations (<code>$inc</code> for MongoDB, <code>UPDATE</code> for Oracle).
    </div>
    <table>
        <tr><th>Metric</th><th>Value</th></tr>
        <tr><td>MongoDB baseline (non-JSON $inc)</td><td>1,991,379 ns</td></tr>
        <tr><td>Oracle baseline (non-JSON UPDATE)</td><td>943,862 ns</td></tr>
        <tr><td>Delta (Oracle - MongoDB)</td><td>-1,047,517 ns</td></tr>
    </table>
    <p class="note">MongoDB's baseline is higher due to journal sync overhead with j:true on replica set. Oracle's SQL/JDBC has lower per-operation latency.</p>

    <h3>Single Field Update</h3>
    <div class="test-category">
        Updates a single field in documents of varying sizes (100, 500, 1000 fields). Tests whether update cost scales with document size.
    </div>
    <table>
        <tr><th>Test Case</th><th>MongoDB (ns)</th><th>OSON (ns)</th><th>Ratio</th><th>Winner</th></tr>
        <tr><td>Single update 100 fields - Update 1 field in 100-field doc</td><td>1,900,402</td><td>1,232,474</td><td>0.65x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Single update 500 fields - Update 1 field in 500-field doc</td><td>1,993,721</td><td>1,062,068</td><td>0.53x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Single update 1000 fields - Update 1 field in 1000-field doc</td><td>2,006,917</td><td>1,116,121</td><td>0.56x</td><td class='winner-oson'>OSON</td></tr>
    </table>

    <h3>Multi-Field Update</h3>
    <div class="test-category">
        Updates multiple fields (3, 5, 10) in a single operation. Tests batch update efficiency.
    </div>
    <table>
        <tr><th>Test Case</th><th>MongoDB (ns)</th><th>OSON (ns)</th><th>Ratio</th><th>Winner</th></tr>
        <tr><td>Multi-update 3 fields - Update 3 fields simultaneously</td><td>1,949,823</td><td>1,158,361</td><td>0.59x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Multi-update 5 fields - Update 5 fields simultaneously</td><td>1,975,875</td><td>1,156,843</td><td>0.59x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Multi-update 10 fields - Update 10 fields simultaneously</td><td>1,965,112</td><td>1,126,143</td><td>0.57x</td><td class='winner-oson'>OSON</td></tr>
    </table>

    <h3>Large Document Update</h3>
    <div class="test-category">
        Updates a single field in increasingly large documents (10KB to 4MB). Tests whether update cost scales with document size. MongoDB must rewrite the entire document; OSON performs in-place partial updates.
    </div>
    <table>
        <tr><th>Test Case</th><th>MongoDB (ns)</th><th>OSON (ns)</th><th>Ratio</th><th>Winner</th></tr>
        <tr><td>Large doc ~10KB - Single field update</td><td>1,977,267</td><td>1,037,956</td><td>0.52x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Large doc ~50KB - Single field update</td><td>1,929,809</td><td>1,050,259</td><td>0.54x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Large doc ~100KB - Single field update</td><td>1,929,778</td><td>1,059,995</td><td>0.55x</td><td class='winner-oson'>OSON</td></tr>
        <tr class='highlight'><td>Large doc ~1MB - Single field update</td><td>2,892,836</td><td>1,113,762</td><td>0.39x</td><td class='winner-oson'>OSON</td></tr>
        <tr class='highlight'><td>Large doc ~4MB - Single field update</td><td>7,385,070</td><td>1,104,344</td><td>0.15x</td><td class='winner-oson'>OSON</td></tr>
    </table>
    <p class="note"><strong>Key Finding:</strong> MongoDB's time increases with document size (O(n) rewrite), while OSON remains constant (~1.1ms) regardless of document size (partial update).</p>

    <h3>Array Push Operations</h3>
    <div class="test-category">
        Appends elements to an array field. Tests <code>$push</code> (MongoDB) vs <code>JSON_TRANSFORM APPEND</code> (Oracle). "10x1" means 10 sequential single-element pushes.
    </div>
    <table>
        <tr><th>Test Case</th><th>MongoDB (ns)</th><th>OSON (ns)</th><th>Ratio</th><th>Winner</th></tr>
        <tr><td>Scalar push 1x1 - Push 1 integer to array</td><td>1,907,349</td><td>1,117,662</td><td>0.59x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Scalar push 10x1 - Push 10 integers (10 operations)</td><td>19,196,365</td><td>11,572,733</td><td>0.60x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Object push 1x1 - Push 1 object to array</td><td>2,028,989</td><td>1,194,319</td><td>0.59x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Object push 10x1 - Push 10 objects (10 operations)</td><td>20,169,646</td><td>13,865,948</td><td>0.69x</td><td class='winner-oson'>OSON</td></tr>
    </table>

    <h3>Array Delete Operations</h3>
    <div class="test-category">
        Removes elements from different array positions (beginning, middle, end). Tests <code>$pull</code> (MongoDB) vs <code>JSON_TRANSFORM REMOVE</code> (Oracle). Middle deletes are particularly expensive for MongoDB due to array shifting.
    </div>
    <table>
        <tr><th>Test Case</th><th>MongoDB (ns)</th><th>OSON (ns)</th><th>Ratio</th><th>Winner</th></tr>
        <tr><td>Scalar delete beginning - Remove first array element</td><td>1,647,896</td><td>1,099,521</td><td>0.67x</td><td class='winner-oson'>OSON</td></tr>
        <tr class='highlight'><td>Scalar delete middle - Remove middle array element</td><td>4,282,104</td><td>1,115,265</td><td>0.26x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Scalar delete end - Remove last array element</td><td>1,640,492</td><td>1,238,377</td><td>0.75x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Object delete beginning - Remove first object from array</td><td>2,336,335</td><td>1,039,076</td><td>0.44x</td><td class='winner-oson'>OSON</td></tr>
        <tr class='highlight'><td>Object delete middle - Remove middle object from array</td><td>4,218,771</td><td>1,048,887</td><td>0.25x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Object delete end - Remove last object from array</td><td>2,274,331</td><td>1,022,622</td><td>0.45x</td><td class='winner-oson'>OSON</td></tr>
    </table>
    <p class="note"><strong>Key Finding:</strong> MongoDB's middle-position deletes are ~4x slower than end deletes due to array element shifting. OSON maintains consistent ~1.1ms regardless of position.</p>

    <h3>Large Array Operations</h3>
    <div class="test-category">
        Appends elements to very large arrays (1MB, 4MB). Tests scalability with array size. MongoDB has specific optimizations for scalar arrays.
    </div>
    <table>
        <tr><th>Test Case</th><th>MongoDB (ns)</th><th>OSON (ns)</th><th>Ratio</th><th>Winner</th></tr>
        <tr><td>Large 1MB scalar array - Push to 1MB integer array</td><td>3,129,667</td><td>4,015,566</td><td>1.28x</td><td class='winner-mongo'>MongoDB</td></tr>
        <tr><td>Large 4MB scalar array - Push to 4MB integer array</td><td>7,660,251</td><td>22,889,482</td><td>2.99x</td><td class='winner-mongo'>MongoDB</td></tr>
        <tr><td>Large 1MB object array - Push to 1MB object array</td><td>4,869,838</td><td>4,817,506</td><td>0.99x</td><td class='winner-oson'>OSON</td></tr>
        <tr><td>Large 4MB object array - Push to 4MB object array</td><td>12,449,115</td><td>18,552,229</td><td>1.49x</td><td class='winner-mongo'>MongoDB</td></tr>
    </table>
    <p class="note"><strong>Key Finding:</strong> MongoDB wins on large scalar arrays (specialized optimization), but performance is closer for object arrays.</p>
</div>

<div class="section">
    <h2>Key Insights</h2>
    <ul>
        <li><strong>Client-side OSON dominates:</strong> 71x faster for field access due to O(1) hash lookup vs BSON's O(n) sequential scanning. The advantage grows with document size.</li>
        <li><strong>OSON partial updates shine at scale:</strong> For large documents (1-4MB), OSON is 2.6-6.7x faster because it modifies only the changed field, not the entire document.</li>
        <li><strong>Middle-position array operations:</strong> OSON is 3-4x faster for deletes from array middle because it doesn't need to shift elements.</li>
        <li><strong>MongoDB wins on large scalar arrays:</strong> MongoDB has specialized optimizations for homogeneous scalar arrays that OSON doesn't match.</li>
        <li><strong>Durability parity is critical:</strong> With j:true, MongoDB baseline is ~2ms (vs ~0.5ms without). This is the fair comparison for production workloads.</li>
    </ul>
</div>

<div class="section">
    <h2>Server-Side Summary</h2>
    <table>
        <tr><th>Category</th><th>MongoDB Wins</th><th>OSON Wins</th><th>Advantage</th></tr>
        <tr><td>Single Field Update</td><td>0</td><td>3</td><td>OSON 1.6-1.9x faster</td></tr>
        <tr><td>Multi-Field Update</td><td>0</td><td>3</td><td>OSON 1.7x faster</td></tr>
        <tr><td>Large Document Update</td><td>0</td><td>5</td><td>OSON 1.8-6.7x faster</td></tr>
        <tr><td>Array Push</td><td>0</td><td>4</td><td>OSON 1.5-1.7x faster</td></tr>
        <tr><td>Array Delete</td><td>0</td><td>6</td><td>OSON 1.3-4x faster</td></tr>
        <tr><td>Large Array</td><td>3</td><td>1</td><td>MongoDB 1.3-3x faster</td></tr>
        <tr style="font-weight: bold; background: #f0f7ff;"><td>TOTAL</td><td>3</td><td>22</td><td>OSON 1.19x faster overall</td></tr>
    </table>
</div>

<div class="note" style="margin-top: 40px; text-align: center;">
    Generated by DocBench - BSON vs OSON Benchmark Suite<br>
    <a href="https://github.com/rhoulihan/DocBench">https://github.com/rhoulihan/DocBench</a>
</div>
</div>
</body>
</html>
